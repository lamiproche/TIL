# 21.06.30(수)
## class 상속
- 클래스에서의 상속 extends, 단일상속
- 상속을 받을 경우 클래스 변수명 뒤에 extends 붙이고 상속받을 클래스 변수명 삽입
- ex)
-    class Father {};
-    public class Me extends Father {};
- 상속의 경우에도 static이 붙어있을 경우 에러 발생
- 클래스는 단일 상속이라 한번에 두개의 클래스를 상속받을 수 없음
- 메인 클래스에서 상속 받을시 클래스 자신을 new 선언하고 상속 클래스 사용
###
- 메소드 안에 들어있는 변수는 : 로컬변수, 지역변수
- 메소드 밖에 있는 변수는 : 전역변수, 멤버변수, 클래스변수, 필드변수
- 상수는 : final변수
- 클래스안에 final이 있으면 상속받을 수 없음. 왜냐, 값 변경을 할 수 없기 때문
- 마찬가지로 final 클래스가 될 시 상속 불가능
###
## interface 상속
- 인터페이스의 상속 implements, 다중상속 (개발자 규칙 생성)
- interface의 삽입 위치는 class 자리 대신에 삽입
- 보통 메소드를 선언함
- interface를 메모라고 말하기도 하고 명세라고 하기도 함
- interface를 상속받아 재정의 하여 사용, 재정의=재활용=OverRiding
- 보통 상속을 받게되면 @Override 생성이 되는데 생략 가능
- 단 상속받지 않는 메소드 위에 @Override 작성 시 에러 발생
- 메소드 선언만 한 것을 abstract method라고 함 (추상 메소드)
- 메소드에 abstract 키워드가 붙기도 하는데 생략 가능
- 인터페이스를 상속받으려면 class 뒤에 implements 붙이고 변수명 작성
- ex)
'''
public interface BoardImp {
  public int  boardCount();
}
'''
-   public class jr implements BoardImp {}
- 인터페이스가 필요한 이유? 개발자간 협업시 엉키는 것을 방지하기 위해 서로간의 규칙 생성
